'use strict';

/**
 * Dependencies
 */
var set = require('lodash.set');
var clone = require('stringify-clone');

var resolvedModuleCache = [];
/**
 * Utilities
 */
var generateResolvers = require('./generate-resolvers');

/**
 * A method for actually resolving a config
 * from type names to React components.
 * Takes a config object to be resolved and
 * an array of paths generated by the
 * function above (generatePaths)
 */
module.exports = function () {
  var getModule = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {
    return console.warn('No getModule() method supplied to constructor');
  };

  return function (config) {
    /**
     * Clone the config object to avoid mutation
     */
    var configCopy = clone(config);
    /**
     * Create an array of resolver specifications
     */
    var resolvers = generateResolvers('app', configCopy.app, function (_ref) {
      var path = _ref.path;
      var module = _ref.module;

      return {
        path: path + '.type',
        type: module.type
      };
    });

    /**
     * Return a Promise of the config
     * resolved with modules
     * (React components instead of type strings)
     */
    return new Promise(function (resolve, reject) {
      var resolvingModules = [];

      // Pick modules from cache or add them to queue to be resolved
      resolvers.map(function (item) {
        if (!resolvedModuleCache[item.type]) {
          resolvedModuleCache[item.type] = 'adding';
          resolvingModules.push(getModule(item.type).then(function (module) {
            return resolvedModuleCache[item.type] = module;
          }));
        }
      });

      // When all new modules are resolved, add them to the configCopy object we are resolving to..
      Promise.all(resolvingModules).then(function () {
        resolvers.forEach(function (resolver) {
          var component = resolvedModuleCache[resolver.type];
          set(configCopy, resolver.path, component);
        });
        resolve(configCopy);
      }).catch(function (err) {
        return reject(err);
      });
    });
  };
};