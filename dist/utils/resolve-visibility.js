'use strict';

/**
 * Dependencies
 */
var set = require('lodash.set');
var clone = require('stringify-clone');

/**
 * Utilities
 */
var generateResolvers = require('./generate-resolvers');

/**
 * Export tool for resolving visibility
 */
module.exports = function () {
  var isVisible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {
    return console.warn('No isVisible() method supplied to constructor');
  };

  return {
    /**
     * A method for actually resolving a config
     * from type names to React components.
     * Takes a config object to be resolved and
     * an array of paths generated by the
     * function above (generatePaths)
     */
    onClient: function onClient() {
      var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      /**
       * Clone the config to avoid mutation
       */
      var configCopy = clone(config);

      /**
       * Create an array of resolver specifications
       */
      var resolvers = generateResolvers('app', configCopy.app, function () {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$path = _ref.path,
            path = _ref$path === undefined ? '' : _ref$path,
            _ref$module = _ref.module,
            module = _ref$module === undefined ? {} : _ref$module;

        return {
          path: path + '.options._hideOnClient',
          value: !!module.visibility && !isVisible(settings, query, module.visibility)
        };
      });

      /**
       * Return a Promise of the config
       * resolved with visibility settings
       * that we'll use for conditionally
       * showing modules on different sized devices
       */
      return new Promise(function (resolve) {
        resolvers.forEach(function (resolver) {
          set(configCopy, resolver.path, resolver.value);
        });

        resolve(configCopy);
      });
    },

    /**
     * A method for actually resolving a config
     * from type names to React components.
     * Takes a config object to be resolved and
     * an array of paths generated by the
     * function above (generatePaths)
     */
    onServer: function onServer() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var configCopy = clone(config);

      /**
       * Create an array of resolver specifications
       */
      var resolvers = generateResolvers('app', configCopy.app, function () {
        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref2$path = _ref2.path,
            path = _ref2$path === undefined ? '' : _ref2$path,
            _ref2$module = _ref2.module,
            module = _ref2$module === undefined ? {} : _ref2$module;

        return {
          path: path + '.options._hideOnServer',
          value: !!module.visibility
        };
      });

      /**
       * Return a Promise of the config
       * resolved with visibility
       * (which platform it should be shown on)
       */
      return new Promise(function (resolve) {
        resolvers.forEach(function (resolver) {
          set(configCopy, resolver.path, resolver.value);
        });

        resolve(configCopy);
      });
    }
  };
};