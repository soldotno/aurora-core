// Dependencies
import set from 'lodash.set';
import clone from 'stringify-clone';

// Utilities
import generateResolvers from './generate-resolvers';

const resolvedModuleCache = [];
/**
 * A method for actually resolving a config
 * from type names to React components.
 * Takes a config object to be resolved and
 * an array of paths generated by the
 * function above (generatePaths)
 */
export default function resolveModules(
  getModule = moduleString => console.warn('No getModule() method supplied to constructor')
) {
  return function resolveModules(config) {
    /**
     * Clone the config object to avoid mutation
     */
    const configCopy = clone(config);
    /**
     * Create an array of resolver specifications
     */
    const resolvers = generateResolvers('app', configCopy.app, ({
      path,
      module,
    }) => {
      return {
        path: `${path}.type`,
        type: module.type,
      };
    });

    /**
     * Return a Promise of the config
     * resolved with modules
     * (React components instead of type strings)
     */
    return new Promise((resolve, reject) => {
      const resolvingModules = [];
      const resolvingModulesKeys = {};

      // Pick modules from cache or add them to queue to be resolved
      const keys = Object.keys(resolvers);
      /* eslint-disable guard-for-in, no-restricted-syntax  */
      for (const itemKey in keys) {
        const item = resolvers[itemKey];
        if (!resolvingModulesKeys[item.type]) {
          resolvingModulesKeys[item.type] = true;

          const modulePromise = new Promise((resolve, reject) =>  {
            getModule(item.type)
              .then(moduleRes => resolve({
                module: moduleRes,
                type: item.type,
              })
              );
          });
          resolvingModules.push(modulePromise);
        }
      }
      /* eslint-enabled guard-for-in, no-restricted-syntax  */

      // When all new modules are resolved, add them to the configCopy object we are resolving to..
      Promise.all(resolvingModules)
        .then((modulesResolved) => {
          resolvers.forEach((resolver) => {
            const moduleObjs = modulesResolved.filter(moduleObj => moduleObj.type === resolver.type);
            if (!moduleObjs || moduleObjs.length > 1) {
              // TODO: how should we handle a moduleString that we can not map?
              throw new Error(`Uknown module: ${JSON.stringify(moduleObjs)}`);
            }
            const moduleObj = moduleObjs[0];
            const component = moduleObj.module;
            set(configCopy, resolver.path, component);
          });
          resolve(configCopy);
        })
        .catch(err => reject(err));
    });
  };
}
